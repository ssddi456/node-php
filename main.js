var url = require("url"); 
var child = require("child_process"); 
var path = require("path"); 
var fs = require("fs"); 

function runPHP(req, response, next, phpdir){
  var parts = url.parse(req.url);
  var query = parts.query;
  
  var file = path.join(phpdir, parts.pathname); 
  var extname = path.extname(file);
  if( extname == '' ){
    file = path.join(file, "index.php"); 
  } else if( extname != '.php' ){
    return next();
  }

  fs.stat( file, function( err, stat) {
    if( err ){
      file = path.join(phpdir,'index.php');
    }

    create_request();
  });
  
  function create_request () {
    var env = { 
      SERVER_SIGNATURE: "NodeJS server at localhost", 
      //The extra path information,
      //as given in the requested URL. 
      //In fact, scripts can be accessed by their 
      //virtual path, followed by extra information 
      //at the end of this path. 
      //The extra information is sent in PATH_INFO.
      PATH_INFO: path.basename(parts.pathname), 
      //The virtual-to-real mapped version of PATH_INFO.
      PATH_TRANSLATED: "", 
      //The virtual path of the script being executed.
      SCRIPT_NAME: parts.pathname,
      
      SCRIPT_FILENAME: file, 

      //The real path of the script being executed.
      REQUEST_FILENAME: file, 

      //The full URL to the current object requested 
      //by the client.
      SCRIPT_URI: req.url, 

      //The full URI of the current request. 
      //It is made of the concatenation of 
      //SCRIPT_NAME and PATH_INFO (if available.)
      URL: req.url, 

      SCRIPT_URL: req.url, 
      //The original request URI sent by the client.
      REQUEST_URI: req.url, 
      //The method used by the current request; 
      //usually set to GET or POST.
      REQUEST_METHOD: req.method, 
      //The information which follows the ? 
      //character in the requested URL.
      QUERY_STRING: parts.query||"", 
      //"multipart/form-data", 
      //"application/x-www-form-urlencoded", 
      //The MIME type of the request body;
      //set only for POST or PUT requests.
      CONTENT_TYPE: req.get("Content-type")||"", 
      //The length in bytes of the request body;
      //set only for POST or PUT requests.
      CONTENT_LENGTH: req.rawBody.length||0, 
      //The authentication type if the client has
      //authenticated itself to access the script.
      AUTH_TYPE: "", 
      AUTH_USER: "", 
      //The name of the user as issued by the client 
      //when authenticating itself to access the script.
      REMOTE_USER: "", 
      //The web server's software identity.
      SERVER_SOFTWARE: "NodeJS", 
      //The host name or the IP address of 
      //the computer running the web server 
      //as givenin the requested URL.
      SERVER_NAME: "localhost", 
      //The IP address of the computer running the web server.
      SERVER_ADDR: "127.0.0.1", 
      //The port to which the request was sent.
      SERVER_PORT: 8011, 
      //The CGI Specification version supported 
      //by the web server; 
      //always set to CGI/1.1.
      GATEWAY_INTERFACE: "CGI/1.1", 
      //The HTTP protocol version used by the current request.
      SERVER_PROTOCOL: "", 
      //The port from which the request was sent.
      REMOTE_PORT: "", 
      //The IP address of the computer that sent the request.
      REMOTE_ADDR: req.headers['x-forwarded-for'] 
                  || req.connection.remoteAddress 
                  || req.socket.remoteAddress 
                  || req.connection.socket.remoteAddress, 
      //The absolute path of the web site files. 
      //It has the same value as Documents Path.
      DOCUMENT_ROOT: "", 
      //The numerical identifier of the host 
      //which served the request. 
      //On Abyss Web Server X1, 
      //it is always set to 1 since there is only 
      //a single host.
      INSTANCE_ID: "", 
      //The virtual path of the deepest alias which contains 
      //the request URI. If no alias contains the request URI, 
      //the variable is set to /.
      APPL_MD_PATH: "", 
      //The real path of the deepest alias which contains 
      //the request URI. 
      //If no alias contains the request URI, 
      //the variable is set to the same value as 
      //DOCUMENT_ROOT.
      APPL_PHYSICAL_PATH: "", 
      //It is set to true if the current request is 
      //a subrequest,
      // i.e. a request not directly invoked by a client. 
      // Otherwise, it is set to true. Subrequests 
      // are generated by the server for internal processing. 
      // XSSI includes for example result in subrequests. 
      IS_SUBREQ: "", 
      REDIRECT_STATUS: 1
    }; 
    var headers = Object.keys(req.headers);
    function line_end_join ( arr ) {
      return arr.reduce(function(a, b){
                return a+b+"\n";
              }, "");
    }

    //All HTTP headers sent by the client. 
    //Headers are separated by carriage 
    //return characters (ASCII 13 - \n) 
    //and each header name is prefixed by HTTP_, 
    //transformed to upper cases, 
    //and - characters it contains are 
    //replaced by _ characters.
    env.ALL_HTTP= line_end_join(
                    headers
                      .map(function(x){
                        return "HTTP_"
                                + x.toUpperCase()
                                    .replace("-", "_")
                                + ": " 
                                + req.headers[x];
                      }));
                    
    //All HTTP headers as sent by the client in raw form.
    //No transformation on the header names is applied.
    env.ALL_RAW= line_end_join(
                    headers
                      .map(function(x){
                        return x+": "+req.headers[x];
                      })); 

    var res = [], err = []; 
    
    var php = child.spawn("php-cgi", [], {
      env: env
    }); 
    
    php.stdin.on("error", function(){}); 
    php.stdin.write(req.rawBody); 

    php.stdout.on("data", function(data){
      res.push(data);
    }); 

    php.stderr.on("data", function(data){
      err.push(data);
    });

    php.on("error", function(err){
      throw err;
    }); 

    php.on("exit", function(){
      // extract headers 
      php.stdin.end(); 
      res = Buffer.concat(res);
      var lines = res
                  .toString()
                  .split("\r\n");
      var line = 0; 
      var c_line
      var html;
      var byte_len = 0;
      if(lines.length){
        for(;'' != (c_line = lines[line]);line ++){
          var m = c_line.split(": "); 
          if(m[0] === ""){
            break; 
          }
          if(m[0] == "Status"){
            response.statusCode=parseInt(m[1]); 
          }
          if(m.length == 2){
            response.setHeader(m[0], m[1]); 
          }
          byte_len += m[0].length + m[1].length + 4;
        }

        html = res.slice(byte_len+2);
      } else {
        html = res; 
      }

      response
        .status(response.statusCode)
        .end(html); 
    });
  }
}

exports.cgi = function(phproot){
  return function(req, res, next){
    var datas = [];
    
    //req.setEncoding('utf8');
    req.on('data', function(chunk) { 
      datas.push(chunk);
    });
    req.on('end', function() {
      // keep encoding for non-utf8 string
      req.rawBody = datas.length 
                      ? Buffer.concat(datas) 
                      : "";
      runPHP(req, res, next, phproot);
    });
  }
}
// exports runPHP for custom use
exports.runPHP = runPHP;
